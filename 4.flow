// Кузнецов Егор, НГУ, 2022
// 4) Дан массив целых чисел [n_1,...,n_k] и число m.
// Найти все пары индексов (i, j) такие, что n_i + n_j == m.
// Сигнатура функции: inds(a : [int], m : int) -> [Pair<int, int>].
// Усложнение: сделать эту функцию сложности O(n log(n)), а не O(n^2).
// Использовать функции: foldi, makeTree, setTree, lookupTree.
import runtime;

inds(a : [int], m : int) -> [Pair<int, int>];
whileSmallerThanM(a : [int], left_boundary : int, right_boundary : ref int, m : int) -> void;
whileEqualM(a : [int], left_boundary : int, right_boundary : int, m : int, delta : int, res : [int]) -> void;

whileSmallerThanM(a, left_boundary, right_boundary, m){
    if((^right_boundary < lenght(a))&& (a[left_boundary] + a[^right_boundary] < m)){
        right_boundary := ^right_boundary + 1;
        whileSmallerThanM(a, left_boundary, right_boundary, m);
    }
}

whileEqualM(a, left_boundary, right_boundary, m, delta, res){
    if((right_boundary + delta < length(a)) && (a[left_boundary] + a[right_boundary + delta] == m)){
        concat(res, [Pair(left_boundary, right_boundary + delta)]);
        delta_plus_one = delta + 1;
        whileEqualM(a, left_boundary, right_boundary, m, delta_plus_one);
    }
}

inds(a, m){
    a = sort(a);
    res = [];
    right_boundary : ref int = ref 0;

    mapi(array, \left_boundary, v -> {
        whileSmallerThanM(array, left_boundary, right_boundary, m);        
        delta = 0;
        whileEqualM(array, left_boundary, ^right_boundary, m, delta);
        v;
    });

    res;
}

main(){
    int_array = [1, 2, 3, 4, 5, 6];
    m = 6;
    println(inds(int_array, m));
}
