// 6) Реализуйте калькулятор для обратной польской записи (RPN) арифметических выражений.
// Напишите функции перевода арифметический выражений в RPN и наоборот.
import runtime;
import string;
import math/math;
import sys/system;
import lingo/pegcode/parsic;
import lingo/pegcode/driver;

ArithmeticsExpression ::= Multiplication, Division, Addition, Substruction, Variable, Double;

Multiplication(left : ArithmeticsExpression, right : ArithmeticsExpression);
Division      (left : ArithmeticsExpression, right : ArithmeticsExpression);
Addition      (left : ArithmeticsExpression, right : ArithmeticsExpression);
Substruction  (left : ArithmeticsExpression, right : ArithmeticsExpression);
Variable      (var  : string);
Double        (val  : double);

calcGrammarInited : ref Maybe<[PegOp]> = ref None();

arithmeticsGrammar() {
    onlyOnce(calcGrammarInited, \ -> {
        compilePegGrammar("#include C:\Users\egork\source\flow9\labs\2nd-block\5\arithmetics.lingo")
    });
}

RPNGrammar() {
    onlyOnce(calcGrammarInited, \ -> {
        compilePegGrammar("#include C:\Users\egork\source\flow9\labs\2nd-block\6\RPN.lingo")
    });
}

AST2RPN(AST: ArithmeticsExpression) -> string {
    switch (AST) {
        Multiplication(l, r): concatStrings(["(", AST2RPN(l), " ", AST2RPN(r), " *)"]);
        Division      (l, r): concatStrings(["(", AST2RPN(l), " ", AST2RPN(r), " /)"]);
        Addition      (l, r): concatStrings(["(", AST2RPN(l), " ", AST2RPN(r), " +)"]);
        Substruction  (l, r): concatStrings(["(", AST2RPN(l), " ", AST2RPN(r), " -)"]);
        Double        (val) : d2s(val);
        Variable      (var) : var;
    }
}
// failed to parse
RNP2AST(RPN: string) ->  ArithmeticsExpression{
    parsic(RPNGrammar(), RPN, defaultPegActions);
}

AST2s(AST: ArithmeticsExpression) -> string {
    switch (AST) {
        Multiplication(l, r): concatStrings(["(", AST2s(l), "*", AST2s(r), ")"]);
        Division      (l, r): concatStrings(["(", AST2s(l), "/", AST2s(r), ")"]);
        Addition      (l, r): concatStrings(["(", AST2s(l), "+", AST2s(r), ")"]);
        Substruction  (l, r): concatStrings(["(", AST2s(l), "-", AST2s(r), ")"]);
        Double        (val) : d2s(val);
        Variable      (var) : var;
    }
}

s2AST(s: string) -> ArithmeticsExpression{
    parsic(arithmeticsGrammar(), s, defaultPegActions);
}

AST2d(AST: ArithmeticsExpression, varsTree: Tree<string, double>) -> double {
    switch (AST) {
        Multiplication(l, r): AST2d(l, varsTree) * AST2d(r, varsTree);
        Division      (l, r): AST2d(l, varsTree) / AST2d(r, varsTree);
        Addition      (l, r): AST2d(l, varsTree) + AST2d(r, varsTree);
        Substruction  (l, r): AST2d(l, varsTree) - AST2d(r, varsTree);
        Double        (val) : val;
        Variable      (var) : lookupTreeDef(varsTree, var, doubleMin);
    }
}

s2RPN(s : string) -> string {
    AST2RPN(s2AST(s));
}

RPN2s(RPN : string) -> string {
    AST2s(RNP2AST(RPN));
}

putVarInTree() -> Tree<string, double> {
    vars = strSplit(getUrlParameter("Variables"), ",");
    fold(vars, makeTree(), \tree, var -> {setTree(tree, var, s2d(getUrlParameter(var)))});
}

main() {
    s = readUntil("\n");
    println(RPN2s(s));
    quit(0);
}
